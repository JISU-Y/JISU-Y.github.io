---
layout: single
title: "[TIL] Javascript - 스코프"
categories: Javascript
tag: [TIL, Javascript, 스코프]
toc: true
author_profile: true
sidebar:
  nav: "docs"
---

# [TIL]

## Javascript 개념

### 스코프

#### 스코프란?

> 모든 프로그래밍 언어의 기본적인 개념으로 **식별자의 유효범위** 뜻한다.
> <br>자바스크립트에서는 다른 언어의 스코프와 구별되는 특징이 있다.

변수, 함수 등 식별자는 자신이 선언된 위치에 의해 자신이 유효한 범위(다른 코드가 자신을 참조할 수 있는 범위)가 결정된다.

이러한 범위를 스코프라고 한다.

- 식별자 결정

  ```jsx
  var x = "global";

  function foo() {
    var x = "local";
    console.log(x); // 1번 / local
  }

  foo();

  console.log(x); // 2번 / global
  ```

  위의 예제에서는 변수명이 똑같은 식별자가 2개가 있는데,
  <br>하나는 전역 변수로 어디서든 참조할 수 있고,
  하나는 foo 함수 내부에서 선언된 변수이기 때문에 함수 내부에서만 참조할 수 있다.
  <br>이름은 같지만 다른 별개의 변수이다.

  자바스크립트 엔진이 console.log(x)를 만났을 때, 어떤 변수를 참조해야 할 것 인지를 결정하는 것을 **식별자 결정(identifier resolution)**이라고 한다.

- 네임 스페이스

  스코프라는 개념이 없다면 같은 이름을 갖는 변수는 전체 프로그램에서 하나 밖에 없어야 한다.
  <br>프로그래밍에서는 이 **스코프(유효범위)라는 개념을 통해 변수 이름 충돌을 방지**하여 같은 이름의 변수를 사용할 수 있도록 한다.

- 스코프의 종류
  | 구분 | 설명 | 스코프 | 변수 |
  | ---- | --------------------- | ----------- | --------- |
  | 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
  | 지역 | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |
  변수는 자신이 **선언된 위치에 의해 스코프가 결정**된다.
  **전역**에서 선언된 변수는 **전역 스코프**를 갖고, **함수 내부**에 선언된 변수는 **지역 스코프**를 갖는다.

  ```jsx
  var x = "global";

  function foo() {
    var x = "local";
    console.log(x); // 1번 / local
  }

  foo();

  console.log(x); // 2번 / global
  ```

  여기처럼 함수 내부에 선언된 x 변수 이외에 같은 이름의 전역 변수가 존재한다.
  **이때 foo 함수 내에서 x를 참조하면 전역 변수를 참조하는 것이 아니라 함수 내부에 선언된 x 변수를 참조하게 된다.**
  이를 식별자 검색(indentifier resolution)이라고 했는데, 자바스크립트 엔진이 **스코프 체인을 통해 이 식별자 검색**을 할 수 있는 것이다.

- 스코프 체인
    <aside style='background-color : gold; opacity: 0.6; padding: 10px 20px'>
    💡 함수 안에 함수를 정의할 수 있는데, 이것을 함수의 중첩이라고 한다.
    <br>함수 안에 정의된 함수를 중첩 함수(nested function),
    <br>이 중첩 함수를 포함하는 함수를 외부 함수(outer function)이라고 한다.
    </aside>
    
    함수가 중첩이 되므로 스코프 또한 중첩이 될 수 있고, 스코프가 함수의 중첩에 의해 계층적 구조를 갖는다. (⇒ 스코프 체인)
    
    자바스크립트 엔진은 스코프를 통해 변수를 참조하는 코드의 스코프부터 시작해서 상위 스코프 방향으로 이동하면서 식별자 검색을 한다.
    <br>그렇기 때문에 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있는 것이다.

- 함수 레벨 스코프

  > 코드 블록이 아니라, **함수에 의해서만 지역 스코프가 생성**되는 것.

    <aside>
    💡 블록 레벨 스코프: 함수 뿐만 아니라 모든 코드 블록(if, for, while ..)이 지역 스코프를 생성하는 것. 대부분의 언어에서 블록 레벨 스코프를 생성한다.
    </aside>

    <br>
    <strong>var 키워드</strong>로 선언된 변수는 <strong>함수 코드 블록</strong>만을 지역 스코프로 인정한다.
    <br>그런데 이는 몇 가지 문제가 있을 수 있다
      
    <br>ex)

  ```jsx
  var i = 10;

  // for 문에서 선언한 i는 전역 변수다.
  // 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
  for (var i = 0; i < 5; i++) {
    console.log(i); // 0 1 2 3 4
  }

  // 의도치 않게 변수의 값이 변경되었다.
  console.log(i); // 5
  ```

  var로 선언한 변수는 함수 레벨 스코프가 적용되므로 for문 밖에서도 사용이 가능하다. (같은 함수 내에서만)
  따라서, 의도치 않은 동작을 일으킬 수 있다.

  그래서 나온 것이 ES6에 도입된 **let, const** 이다. 이는 **블록 레벨 스코프를 지원**한다.

- 렉시컬 스코프

  - 예제)

    ```jsx
    var x = 1;

    function foo() {
      var x = 10;
      bar();
    }

    function bar() {
      console.log(x);
    }

    foo(); // ?
    bar(); // ?
    ```

    결과 값은 bar 함수의 상위 스코프가 무엇인지에 따라 달라진다.

  1. **동적 스코프**
     함수를 어디서 호출했는지에 따라 상위 스코프를 결정하는 것.
     <br>이렇게 스코프를 결정하면 위의 예제에서는 bar의 상위 스코프는 foo 함수의 스코프이다.
  2. **렉시컬 스코프**
     함수를 어디서 정의했는지에 따라 상위 스코프를 결정하는 것. 정적 스코프라고도 한다.
     <br>함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.
     <br>**자바스크립트는 이 스코프를 따른다**.
     그러면, 호출될 때는 자기 상위 스코프를 어떻게 알 수 있을까?
     <br>함수 정의가 실행되어 생성된 함수 객체는 결정된 **상위 스코프를 기억**한다.
     따라서, 함수를 어디서 호출했는지가 중요한 게 아니라, 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.
