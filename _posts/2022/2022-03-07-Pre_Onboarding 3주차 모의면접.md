---
layout: single
title: "[Course / TIL] Wanted Pre Onboarding FE Course 3주차 - 모의 면접 / 팀 과제 5 시작"
categories: Course
tag: [Course, TIL, Wanted, PreOnboarding, CSS, Javascript, 면접 대비]
toc: true
author_profile: true
sidebar:
  nav: "docs"
---

# Course

**Wanted Pre Onboarding FE Course**

## 모의 면접 대비

### CSS 관련 질문

#### CSS보다 SCSS/SASS가 가진 장점에 대해 설명하세요.

SCSS와 SASS는 CSS의 전처리기로 CSS보다 쉬우면서, 추가적인 기능을 제공한다.
<br>스타일링 코드 중복을 줄일 수 있다.
<br>CSS의 특성상, 셀렉터를 중복해서 사용해야 하는 경우가 많은데, SASS의 Nesting을 이용해 코드의 양을 줄이고, 연관된 코드를 그룹화 할 수 있다.
<br>변수를 사용할 수 있다.
<br>$ 로 시작하는 변수를 지정해, 크기나 색상과 같은 값을 일괄적으로 변경할 수 있게 해준다.
<br>함수와 연산자를 사용할 수 있다.
<br>mixin을 사용해 사이트 전체적으로 자주 쓰이는 CSS 그룹을 만들고 재사용할 수 있다.
<br>extend를 사용해 특정 셀렉터를 상속할 수 있게 하여, 셀렉터에 정의된 값을 한 곳에서 관리할 수 있게 한다.
<br>이러한 SCSS와 SASS의 장점은 코드를 쉽게 관리할 수 있게 하여 유지보수성을 극대화한다.

#### CSS, SCSS, SASS의 차이점과 리액트와 사용할 거면 무엇을 쓸 건지 설명하세요.

SCSS와 SASS는 CSS의 preprocessor(전처리기)로, CSS에 기능을 추가한 것이다.

SCSS는 CSS 문법에 SASS 문법을 섞은 것이며, SASS 컴파일러로 그대로 컴파일 될 수 있다.

CSS와 CSS 전처리기의 차이점

SASS/SCSS에서는 Nesting을 이용해 연관된 코드를 그룹화 할 수 있다. 변수, 함수, 연산자를 만들어 사용할 수 있다. mixin을 이용해 CSS 그룹을 만들고, 재사용할 수 있다. extend를 사용해 특정 셀렉터를 상속할 수 있다.

SASS와 SCSS의 차이점

문법 차이가 있다.
SCSS는 CSS의 문법을 그대로 사용하고, SASS는 줄바꿈으로 구별한다. 따라서 SCSS가 CSS와의 호환성이 비교적 좋다.
SASS는 들여쓰기와 줄 바꿈이 문법의 요소이기 때문에 여러 줄 쓰기를 지원하지 않는다.
SCSS는 CSS 문법을 따라가기 때문에 세미콜론을 사용해야 한다. 반면 SASS는 세미콜론을 사용하지 않는다.

리액트와 사용할 경우 SASS와 SCSS 중 어느 것을 사용할지?

node-sass 라이브러리를 사용하면 SASS를 CSS로 변환해준다. 또한 SASS는 SCSS와 완전히 호환되기 때문에, 사용성에 있어서는 큰 차이가 없을 것이다. 하지만 라이브러리를 추가로 설치하지 않고 싶어 CSS혹은 SCSS를 사용할 것 같다.

#### id와 class 셀렉터의 차이점에 대해 설명하세요.

id는 문서 안의 유일한 요소를 식별하고 싶을 때 사용하며, class는 공통점이 있는 여러 요소를 그룹화하여 식별하고 싶을 때 사용한다.

CSS에서 id는 샾(#)를 앞에 붙이며, class는 피리어드(.)을 붙여서 구별한다.

또한 id는 class의 속성보다 우선순위가 높으며, id의 속성은 해당 요소에 부여된 class의 속성과 관계없이 작동한다.

#### CSS 박스 모델에 대해서 설명하세요.

모든 HTML 요소는 박스 모양으로 구성되기 때문에, 이를 박스 모델이라고 한다.

박스 모델에서는 각 HTML 요소들에 content, padding, border, margin 있다.

content: 박스의 실질적 내용으로, 텍스트나 이미지 등 요소의 실제 내용이 들어간다.
<br>padding: content와 border 사이에 있는 안쪽 여백이다.
<br>border: content와 padding을 감싸는 테두리이다.
<br>margin: border를 기준으로 이웃하는 요소 사이의 간격이다.

#### CSS에서 px, em, rem, vh, vw 단위들의 차이점은 무엇인가요?

길이를 나타내는 단위는 절대 길이 단위와 상대 길이 단위로 나뉜다.

절대 길이 단위
절대 길이 단위는 물리적인 측정 거리를 의미한다.

px
px은 절대 길이 단위로, 일반적인 모니터 디스플레이의 1 픽셀을 의미한다.

상대 길이 단위
상대 길이 단위에는 글꼴 상대 길이와 뷰포트 백분율 길이가 있다. 글꼴 상대 길이는 길이값을 특정 문자나 현재 사용하는 폰트를 기준으로 설정하는 반면, 뷰포트 백분율 길이는 길이값을 뷰포트를 기준으로 설정한다.

em, rem 은 글꼴 상대 길이이며, vh, vw는 뷰포트 상대 길이이다.

em은 부모 요소의 폰트 사이즈를 기준으로 하는 반면, rem은 루트 요소(일반적으로 `<html>` 요소)의 폰트 사이즈를 기준으로 한다.

vh는 뷰포트의 초기 컨테이너 블록의 높이의 1%를 기준으로, vw는 뷰포트의 초기 컨테이너 블록의 너비의 1%를 기준으로 한다.

#### CSS 레이아웃 기법의 종류와 특징에 대해서 설명하세요. (grid, flexbox)

CSS 레이아웃 기법에는 크게 Flexbox와 grid 두가지가 있다.

flexbox는 flexible box module의 준말로, 1차원으로 X축 또는 Y축 방향으로 요소를 배치, 정렬할 수 있다. 또한, 각 요소의 순서를 변경할 수 있기 때문에, 손쉽게 멀티 스크린에 대응할 수 있다.

grid는 테이블처럼 2차원으로 세로 열과 가로 행을 기준으로 요소를 정렬한다. HTML 문서 위계 구조와 무관하게 행과 열 격자 구조에 요소를 자유롭게 배치할 수 있다.

#### CSS in JS(styled component)의 장단점에 대해서 설명하세요.

장점

class명이 유니크한 해시값으로 변경되기 때문에 클래스 네임 중복을 신경쓰지 않아도 된다.
<br>CSS in JS에서는 컴포넌트와 CSS가 동일한 구조로 관리되기 때문에 불필요해진 CSS를 삭제하거나 수정하는 등 관리하기 쉽다.
<br>CSS in JS에서는 CSS코드를 자바스크립트 파일에 작성하기 때문에, 컴포넌트의 상태에 따른 동적 코딩이 가능하다.
<br>CSS in JS에서는 CSS가 컴포넌트 스코프에서만 적용되기 때문에, 우선순위 문제가 발생하지 않는다.

단점

번들의 크기가 커진다. CSS in JS를 사용하기 위해서는 styled-component, styled system, rebass 등 라이브러리를 추가하게 되는데, 이는 번들 사이즈를 크게하기 때문에 즉, 첫 로딩 시간이 길어진다.
<br>특히나 CSS in JS는 자바스크립트가 모두 로딩된 후 CSS 코드가 생성되기 때문에 더 느려진다.

인터렉션이 비교적 늦다. CSS in CSS는 상태에 맞는 스타일을 전부 미리 만들어두기 때문에, 상태가 변하면 만들어둔 스타일을 바로 적용할 수 있다. 반면, CSS in JS를 사용하면, 상태가 변경되면 자바스크립트의 CSS 코드를 읽어와 파싱하는 단계부터 시작한다. 따라서 CSS in CSS에 비해 CSS 적용이 느릴 수밖에 없다.

#### position 속성과 z-index의 연관성에 대해 설명하세요.

position 속성이 없는 태그는 순서대로 쌓인다.
<br>position 속성이 있는 태그들은 없는 태그들보다 위에, 나오는 순서대로 쌓인다.
<br>position 속성과 z-index 값이 있으면 z-index 값이 큰 태그가 위에 쌓인다.
<br>z-index 값이 커도 부모 태그의 z-index가 우선된다.

### Javascript 관련 질문

#### event loop에 대해서 설명하세요.

브라우저 혹은 Node.JS 런타임에 내장되어 있는 기능으로 싱글 스레드 언어인 자바스크립트를 비동기 처리를 할 수 있도록 도와준다.

이벤트 루프는 콜 스택과 콜백 큐를 모니터링하면서 콜 스택이 비어있으면 콜백 큐에서 이벤트를 콜 스택으로 옮겨주어 실행되게 하는 역할을 한다.

콜 스택은 코드들의 실행 컨텍스트들이 쌓여 하나씩 실행되는 곳이고, 콜백 큐는 콜백 펑션들이 쌓아지는 자리이다.

따라서, 콜 스택이 실행되다가 fetch, setTimeout 등 web api를 사용하여 콜백 펑션을 전달한 경우 web api가 처리하도록 전달한 후, 다음 실행 컨텍스트를 실행한다. web api에서 처리가 끝나면 web api는 콜백 큐에 콜백 펑션을 저장하고 있다가, 콜 스택이 비었을 때 이벤트 루프가 콜백 큐의 펑션을 콜 스택에 추가함으로써 실행된다.

#### callback, promise, async/await 의 특징과 차이점에 대해서 설명하세요.

콜백 함수의 정의
일반적으로, 다른 함수의 인자(argument)로 전달되는 함수를 callback 함수라고 부른다.

브라우저, node.js는 비동기 작업을 처리하기 위해서 callback 함수를 자주 사용했지만, 콜백 함수로 비동기를 구현하게 되면 콜백 헬이 발생하여 코드의 가독성을 떨어뜨리고, 실수를 유발할 가능성이 높아진다.

따라서 이를 해결하기 위해서 Promise가 새롭게 등장했는데, Promise 는 비동기 코드를 간편하게 처리할 수 있게 도와주는 자바스크립트의 객체이다.

Promise 클래스의 인스턴스를 생성할 때 자동으로 실행될 executor 라는 콜백함수를 전달해줘야 하는데, executor에는 또 다시 두가지 콜백함수를 전달해야 한다.

작업이 성공한 경우 실행될 resolve 함수를, 작업이 실패한 경우 실행될 reject 함수를 전달한다.

프로미스의 인스턴스가 생성되는 동시에 executor 콜백함수가 실행되며 제대로 실행이 되었을때 최종적으로 resolve함수로 전달된 인자가 인스턴스의 결과값으로 전달된다.

반대로 실행 중에 에러가 발생하면 reject함수로 전달된 인자가 인스턴스의 결과값으로 전달된다.

프로미스의 인스턴스는 항상 다음 세가지 중 하나의 상태(state)를 가진다.

pending(대기): 이행되거나 거부되지 않는 초기 상태
fulfilled(이행): 연산이 성공적으로 완료됨.
rejected(거부): 연산이 실패함.

Promise.prototype.then() Promise.prototype.catch() 메소드는 프로미스를 리턴하기 때문에 Promise Chaining이 가능하다.

하지만 Promise 비동기 처리가 많아질수록 가독성이 크게 좋지 않아 Async/Await를 많이 사용하게 된다

Promise를 기반으로 동작하며 마치 동기적으로 동작하는 것처럼 보인다.

await 키워드는 async 함수 내에서만 사용가능하며, await 키워드로 비동기 코드를 처리하면 응답이 올때까지 코드 읽기를 멈췄다가 요청이 오고 나서야 다음 코드를 실행한다.

await 키워드로 실행된 코드는 Promise가 아닌 Promise의 result에 담긴 값을 반환한다. 따라서 코드의 가독성이 매우 좋아진다.

#### Blocking과 Non-Blocking의 차이점은 무엇인가요?

Blocking
<br>Blocking은 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고, 호출한 함수가 대기하도록 합니다. 예를 들어 실행하는데 10초가 걸리는 A 라는 함수가 실행되면 B라는 함수가 실행되려면 10초간 대기해야 합니다.

Non-blocking
<br>Non-Blocking은 호출된 함수가 할 일을 마치지 않았더라도 바로 제어권을 내주어 호출한 함수가 다른 일을 진행할 수 있는 것입니다. 예를 들어, A함수가 종료되지 않은 상태여도 바로 B함수를 실행할 수 있습니다.

#### Synchronous execution과 Asynchronous execution의 차이점은 무엇인가요?

Synchronous execution 동기적 실행은 한 작업이 끝남과 동시에 다음 작업이 실행되는 실행 방식이다. 예를 들어, 함수 A가 실행이 완료되자마자 함수 B가 연속으로 실행되었다면 이것은 동기적 실행이다.

싱글 스레드에서 Synchronous execution은 한 번에 하나씩 작업을 하게 된다. 멀티 스레드인 경우에도 동기적으로 실행된다면 A 작업이 끝날 때 까지 B 작업은 기다려야 한다.

Asynchonous execution 비동기 실행은 한 작업이 끝나기 전에 다른 작업을 수행할 수 있다. 예를 들어, 함수 A가 실행중인데, 함수 B가 실행되었다면 이는 비동기적 실행이다.

싱글 스레드에서 Asynchonous execution은 한 스레드에서 여러 작업을 수행할 수는 있지만, 결국 한 번에 여러 작업을 수행할 수는 없다. 반면에, 멀티 스레드인 경우 여러 작업이 비동기로 실행되는 경우 여러 스레드가 동시에 작업을 할 수 있다.

#### nodejs는 싱글쓰레드인가요?

Node.js 자체는 싱글스레드 방식이 아니다.
node.js나 브라우저 안에 자바스크립트 엔진이 싱글 스레드로 동작하는 것이고, node.js나 브라우저 자체는 멀티 스레드로 동작한다. 이때 동시 작업을 이벤트 루프를 통해서 구현할 수 있다.

#### nodejs는 event-driven architecture 인가요?

event-driven architecture가 무엇인가?

발생하는 이벤트의 생성과 감지, 소비 및 시스템 상태의 중대한 변화를 지원하는 소프트웨어의 모델 혹은 아키텍처 패러다임을 의미합니다.

그러니까, 특정 동작이 자동으로 혹은 순서에 따라 발생하도록 하는 것이 아니라 어떤 이벤트가 발생하면 동작하도록 하는 디자인 패턴이다.

event-driven architecture의 예시를 들어줄 수 있는지?
판매중인 컴퓨터(제품)를 사용자가 구매해서 판매됨(sold)으로 상태가 바뀌게 되었을 때 컴퓨터(제품)의 상태 변화를 감지한 시스템에서 이벤트를 발생하게 되고 또 다른 관련 부서 시스템에 자동으로 전송. 이후 전송된 이벤트는 각 시스템의 요구에 따라 적절한 처리 과정을 거치게 됩니다. 끊임없이 변화하며 상호작용하는 데이터 간 흐름에서 사용자가 일으킨 ‘event’, 즉 키보드와 마우스 조작이 상황에 따라 그에 반응하는 코드와 끊임없이 새로운 관계를 맺는 것을 예로 들 수 있겠습니다.

Node.js는 event-driven architecture인가?
Node.js 는 event-driven architecture이다.
Node.js에는 HTML 요소가 없기 때문에 대부분의 event는 프로세스, 네트워크, 파일과의 상호 작용 등에서 비롯 됩니다. 따라서 Node.js 는 event-driven architecture라 할 수 있습니다.

#### this와 dynamic scoping

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.

객체 리터럴로 객체를 생성할 때에는 재귀적으로 객체 이름을 사용하여 프로퍼티와 메서드를 참조할 수 있지만, 생성자 함수로 객체를 생성할 때에는 생성자 함수를 정의할 때 객체/인스턴스가 생기는 것이 아니기 때문에 객체 혹은 인스턴스를 미리 가리킬 만한 키워드가 필요하다.

이를 자바스크립트에서는 this 식별자를 통해 객체 혹은 인스턴스의 메서드와 프로퍼티를 참조할 수 있다.

dynamic scoping은 함수를 정의한 위치가 아니라 함수를 호출한 위치에서 동적으로 상위 스코프를 결정하는 것을 뜻한다.

this는 함수가 호출되는 시점에서 결정되기 때문에 dynamic scope를 따르게 된다.

#### 객체 지향 프로그래밍이란 무엇인가요?

객체 지향 프로그래밍은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.

예를 들어 사람은 이름, 주소, 성별, 나이, 신장, 체중 등 다양한 속성을 갖고 있기 때문에 이런 사람이라는 실체를 객체로 표현하면 다음과 같습니다.

```jsx
const person = {
  name: "lee",
  address: "Seoul",
};
```

또한 객체 지향 프로그래밍에서는 상속의 개념을 이용하여 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있다.

javascript는 프로토타입을 기반으로 생성자 함수를 통해 인스턴스를 생성할 때 상속을 구현하여 불필요한 중복을 제거할 수 있다.

상속은 코드의 재사용이란 관점에서 매우 유용하다. 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해 두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현 없이 상위(부모) 객체인 프로토타입의 프로퍼티를 공유하여 사용할 수 있게 된다.

#### Prototype Chaining

Prototype Chaining은 기존에 존재하는 객체를 기반으로 새로운 객체를 생성할 때 사용된다.
만약 특정 객체에 a라는 프로퍼티에 접근하려고 할때, a라는 프로퍼티가 없다면, `__proto__` 접근자 프로퍼티를 따라서 본인의 부모 역할을 하는 객체를 순차적으로 찾아 올라가며 검색한다. 이를 Prototype Chaning이라고 하며 최상위 객체는 Object.prototype이다.

#### IIFE

IIFE는 무엇인가요?
<br>Immediately Invoked Function Expressions으로 즉시 실행 함수를 의미한다.
<br>함수 정의와 동시에 즉시 호출되며 단 한번만 호출이 되고 다시 호출할 수 없는 특성이 있다.

IIFE는 언제 사용하나요?
<br>Javascript에서는 함수가 어떻게 정의되었는지 혹은 어떻게 호출되었는지에 따라서 scope가 정해지게 됩니다. 이를 활용하여 변수나 메소드가 접근되는 것을 closure가 보호해줄 수 있는데 이를 private scope라 하며 주로 이런 상황에 IIFE가 사용됩니다.

예를 들어, init이라는 이름의 함수를 전역에 정의를 했다면, 이름 충돌이 발생하고, 다른 개발자에 의해 의도하지 않은 곳에서 재호출될 수도 있다. 따라서, 단 한번만 호출하는 함수를 사용해서 전역 스코프 오염을 방지, 다른 개발자가 실수로 호출할 수 없도록 한다. init 함수를 즉시 실행 함수로 감싼다.

또한, IIFE를 적용해 closure를 조정하여 'count' 변수를 외부에서 참조하지 못하도록 보호 할수 있게 될 것입니다.

https://medium.com/sjk5766/iife-immediately-invoked-function-expression-%EC%A0%95%EB%A6%AC-53ab6543b828

#### setTimeout 에서 this는 왜 전역을 가리키는지 설명하세요.

this는 함수가 호출될 때 결정됩니다.

setTimeout()에 의해 실행된 코드는 별도의 실행 컨텍스트에서 setTimeout이 호출된 함수로 호출됩니다.

호출된 함수에 대해서는 this 키워드를 설정하는 일반적인 규칙이 적용되며, this를 설정 혹은 할당하지 않은 경우, non-strict 모드에서 전역(혹은 window) 객체, strict모드에서 undefined를 기본 값으로 합니다.

따라서 setTimeout에서는 this가 전역을 가리키게 되는 것이다.

#### 스택과 힙의 차이에 대해서 설명하세요.

자바스크립트는 콜스택과 메모리힙이라는 자료구조를 통해 데이터 및 코드의 실행을 관리합니다.

콜 스택(call stack) 영역
<br>원시타입(숫자 등) 데이터가 저장됩니다.

메모리힙(memory heap) 영역
<br>참조타입(배열, 객체, 함수 등) 데이터가 저장됩니다.
즉 참조타입 데이터를 선언을 하게 되면 해당 주소값만 콜 스택에 저장되고 주소값에 따른 value는 힙에 저장됩니다.

#### call-by-value에 대해서 설명하세요.

call-by-value는 함수 호출 방식 중 하나입니다. 값에 의한 호출이라고도 부릅니다.

기본적으로 자바스크립트는 원시값을 argument 로 넘겨주면 call-by-value 의 형태로 작동합니다.

함수를 호출하게 되면 arguments로 값이 넘어오고, 그 값은 복사된 값으로 넘어옵니다.

caller가 인자를 복사해서 넘겨줬으므로 callee에서 해당 인자를 변형시켜도 caller는 영향을 받지 않습니다.

```jsx
var a = 1;
var func = function (b) {
  // callee
  b = b + 1;
  console.log(b); // 2
};
func(a); // caller
console.log(a); // 1
```

call-by-reference

arguments로 reference(값에 대한 참조 주소, 메모리 주소를 담고있는 변수) 주소값을 넘겨줍니다.

reference가 가리키는 주소값을 얕은 복사로 넘겨주게 됩니다.

caller가 인자를 주소값만을 복사했기 때문에 callee에서 해당 인자를 변경하면 caller는 영향을 받습니다.

```jsx
var a = {};
var func = function (b) {
  // callee
  b.a = 1;
};
func(a); // caller
console.log(a.a); // 1
```

## 회고 (TIL)

**2022.03.07 Daily 회고**

✏오늘 한 일

- CSS, Javascript 모의 면접 질문 정리 및 발표 연습
- 페어 모의 면접
- 팀 과제 회의 및 수행
  - 모달 제작
  - 웬 접근성

⁉느낀 점

css, javascript 심화는 역시 어렵다. 대충 알고 있으면 설명하기 까다로워지기 때문에 잘 모른다면 아예 모른다고 답하는 게 좋을 것 같다는 생각이 든다. 심지어 오늘 한 양보다 훨씬 더 많은데..

웹 접근성을 고려하는 것이 엄청 어렵다! 그래도 역시 우리 팀원 덕분에 배운다.

🎃현재 나의 상태

피곤하고 집중이 잘 되지 않는 상태. 큰일이다. 정신이 나가서 일주일 동안 안들어오고 있다~~

<hr>
